{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Vanetza in a nutshell Vanetza is an open-source implementation of the ETSI C-ITS protocol suite. Among others, it comprises the following protocols and features: GeoNetworking (GN) Basic Transport Protocol (BTP) Decentralized Congestion Control (DCC) Security Support for ASN.1 messages (Facilities) such as CAM and DENM Though originally designed to operate on ITS-G5 channels in a Vehicular Ad Hoc Network (VANET) using IEEE 802.11p, Vanetza and its components can be combined with other communication technologies as well, e.g. GeoNetworking over IP multicast. Project layout In the first place, Vanetza is a conglomerate of C++ libraries, some depending on others. Sources of these libraries, also known as Vanetza component, are bundled in their respective subdirectories. Component Depends on Features access net Access layer, helpers for IEEE 802.11 PHY and MAC asn1 - Generated code and wrappers for ASN.1 based messages, e.g. CAM and DENM btp geonet Headers and interfaces for BTP transport layer common - General purpose classes used across Vanetza components, including serialization and timing dcc access, net Algorithms for DCC cross-layer facilities asn1, geonet, security Helpers to generate and evaluate ITS messages geonet dcc, net, security GeoNetworking layer featuring geographical routing gnss - Satellite navigation integration for positioning net common Utilities for socket API and packet handling security common, net Security entity to sign and verify packets For most of the code unit tests exist. We are using Googletest for those. Compilation of Vanetza unit tests can be enabled via the BUILD_TESTS CMake option. You can the run those tests in your build directory by executing ctest . Additionally, the tools directory contains several utilities making use of Vanetza libraries. Tool Purpose CMake option benchmark Benchmarking security features, e.g. signing or validating a lot messages in a row BUILD_BENCHMARK certify Utility for generating and handling security certificates, authorization tickets etc. BUILD_CERTIFY socktap Example application using most of the Vanetza stack operating on sockets, i.e. either Linux packet sockets or optionally Cohda LLC sockets BUILD_SOCKTAP Deployments Vanetza has been developed for network simulations and testing on embedded devices at Technische Hochschule Ingolstadt initially. Meanwhile, Vanetza is used by many more parties and for more use cases than anticipated in the beginning. Artery is a V2X simulation framework based on OMNeT++ . Vanetza is used in this network simulation as (quite detailed) model of ITS-G5 protocols. Various communication units (roadside units, vehicles and testbeds) in the CARISSMA Car2X lab are powered by Vanetza. Prototype motorcycles operated by the Connected Motorcycle Consortium use Vanetza for evaluation of novel ITS applications to enhance rider safety. If you are using Vanetza, we would love to add your project to the list above. Please write an e-mail to raphael.riebl@thi.de or open a pull request.","title":"Overview"},{"location":"#vanetza-in-a-nutshell","text":"Vanetza is an open-source implementation of the ETSI C-ITS protocol suite. Among others, it comprises the following protocols and features: GeoNetworking (GN) Basic Transport Protocol (BTP) Decentralized Congestion Control (DCC) Security Support for ASN.1 messages (Facilities) such as CAM and DENM Though originally designed to operate on ITS-G5 channels in a Vehicular Ad Hoc Network (VANET) using IEEE 802.11p, Vanetza and its components can be combined with other communication technologies as well, e.g. GeoNetworking over IP multicast.","title":"Vanetza in a nutshell"},{"location":"#project-layout","text":"In the first place, Vanetza is a conglomerate of C++ libraries, some depending on others. Sources of these libraries, also known as Vanetza component, are bundled in their respective subdirectories. Component Depends on Features access net Access layer, helpers for IEEE 802.11 PHY and MAC asn1 - Generated code and wrappers for ASN.1 based messages, e.g. CAM and DENM btp geonet Headers and interfaces for BTP transport layer common - General purpose classes used across Vanetza components, including serialization and timing dcc access, net Algorithms for DCC cross-layer facilities asn1, geonet, security Helpers to generate and evaluate ITS messages geonet dcc, net, security GeoNetworking layer featuring geographical routing gnss - Satellite navigation integration for positioning net common Utilities for socket API and packet handling security common, net Security entity to sign and verify packets For most of the code unit tests exist. We are using Googletest for those. Compilation of Vanetza unit tests can be enabled via the BUILD_TESTS CMake option. You can the run those tests in your build directory by executing ctest . Additionally, the tools directory contains several utilities making use of Vanetza libraries. Tool Purpose CMake option benchmark Benchmarking security features, e.g. signing or validating a lot messages in a row BUILD_BENCHMARK certify Utility for generating and handling security certificates, authorization tickets etc. BUILD_CERTIFY socktap Example application using most of the Vanetza stack operating on sockets, i.e. either Linux packet sockets or optionally Cohda LLC sockets BUILD_SOCKTAP","title":"Project layout"},{"location":"#deployments","text":"Vanetza has been developed for network simulations and testing on embedded devices at Technische Hochschule Ingolstadt initially. Meanwhile, Vanetza is used by many more parties and for more use cases than anticipated in the beginning. Artery is a V2X simulation framework based on OMNeT++ . Vanetza is used in this network simulation as (quite detailed) model of ITS-G5 protocols. Various communication units (roadside units, vehicles and testbeds) in the CARISSMA Car2X lab are powered by Vanetza. Prototype motorcycles operated by the Connected Motorcycle Consortium use Vanetza for evaluation of novel ITS applications to enhance rider safety. If you are using Vanetza, we would love to add your project to the list above. Please write an e-mail to raphael.riebl@thi.de or open a pull request.","title":"Deployments"},{"location":"api/","text":"An API documentation can be generated directly from source code with Doxygen . If Doxygen is installed on your system, you may simply call doxygen in the repository\u2019s root directory. The generated HTML documentation can then be found at doxygen/html/index.html . We also maintain an online copy which is updated every now and then. Of course, your locally generated documentation will be more up-to-date in most cases. Please consider to generate the documentation locally if you need it to match a particular or more recent version of Vanetza.","title":"API Documentation"},{"location":"how-to-build/","text":"How to build Building Vanetza is accomplished by the CMake build system. Hence, CMake needs to be available on the build host. Prerequisites You need following tools and libraries on your system for compiling Vanetza: C++11 compatible compiler, e.g. GNU GCC or Clang CMake 3.1 or higher Boost 1.58 or higher GeographicLib 1.37 or higher Crypto++ 5.6.1 or higher If OpenSSL (1.0 or 1.1) or LibreSSL is available on your system, an alternative security backend implementation is compiled along with the Crypto++ based backend. See security::Backend and security::create_backend for more details. Compilation Following command line snippet demonstrates the build process using a generated Makefile. Other CMake generators and build directory setups can be used as well. cd vanetza mkdir build && cd build cmake .. make Unit tests Vanetza comes with many unit tests covering the most critical parts. When the CMake option BUILD_TESTS is enabled, the Google Test sources are downloaded by the build system automatically. The built test cases are standalone executables located in the tests subdirectory of your build directory. For running all test cases, I recommend to invoke ctest in your build directory. Integrating Vanetza Vanetza is primarily a library project intended for integration by other projects, e.g. V2X simulation tools such as Artery . Projects using CMake can integrate Vanetza most easily by calling find_package(Vanetza) and then refer to the imported Vanetza targets, such as Vanetza::vanetza .","title":"How to build"},{"location":"how-to-build/#how-to-build","text":"Building Vanetza is accomplished by the CMake build system. Hence, CMake needs to be available on the build host.","title":"How to build"},{"location":"how-to-build/#prerequisites","text":"You need following tools and libraries on your system for compiling Vanetza: C++11 compatible compiler, e.g. GNU GCC or Clang CMake 3.1 or higher Boost 1.58 or higher GeographicLib 1.37 or higher Crypto++ 5.6.1 or higher If OpenSSL (1.0 or 1.1) or LibreSSL is available on your system, an alternative security backend implementation is compiled along with the Crypto++ based backend. See security::Backend and security::create_backend for more details.","title":"Prerequisites"},{"location":"how-to-build/#compilation","text":"Following command line snippet demonstrates the build process using a generated Makefile. Other CMake generators and build directory setups can be used as well. cd vanetza mkdir build && cd build cmake .. make","title":"Compilation"},{"location":"how-to-build/#unit-tests","text":"Vanetza comes with many unit tests covering the most critical parts. When the CMake option BUILD_TESTS is enabled, the Google Test sources are downloaded by the build system automatically. The built test cases are standalone executables located in the tests subdirectory of your build directory. For running all test cases, I recommend to invoke ctest in your build directory.","title":"Unit tests"},{"location":"how-to-build/#integrating-vanetza","text":"Vanetza is primarily a library project intended for integration by other projects, e.g. V2X simulation tools such as Artery . Projects using CMake can integrate Vanetza most easily by calling find_package(Vanetza) and then refer to the imported Vanetza targets, such as Vanetza::vanetza .","title":"Integrating Vanetza"},{"location":"legal/","text":"Legal Notice As maintainer of Vanetza, I am responsible for this website\u2019s content under German Law. Following contact details are given to comply with \u00a7 5 TMG and \u00a7 55 Abs. 2 RStV. Feel free to send me a postcard if you like Vanetza :-) Contact Raphael Riebl Bergstra\u00dfe 9 85129 Unterdolling Germany E-mail: raphael@riebl.net I will not answer support requests via e-mail. Please open an issue ticket instead. Privacy Statement I do not collect, store or process any information about visitors of this website. Please note that the API documentation generated by Doxygen sets a non-essential cookie storing your preferred width of its navigation\u2019s sidebar. This website is hosted by GitHub. They likely record some personally identifiable information such as your IP address. Please refer to GitHub\u2019s privacy statement for details. Furthermore, web fonts are included via Google Fonts API . Google has added a section to their FAQ about privacy implications .","title":"Legal Notice"},{"location":"legal/#legal-notice","text":"As maintainer of Vanetza, I am responsible for this website\u2019s content under German Law. Following contact details are given to comply with \u00a7 5 TMG and \u00a7 55 Abs. 2 RStV. Feel free to send me a postcard if you like Vanetza :-)","title":"Legal Notice"},{"location":"legal/#contact","text":"Raphael Riebl Bergstra\u00dfe 9 85129 Unterdolling Germany E-mail: raphael@riebl.net I will not answer support requests via e-mail. Please open an issue ticket instead.","title":"Contact"},{"location":"legal/#privacy-statement","text":"I do not collect, store or process any information about visitors of this website. Please note that the API documentation generated by Doxygen sets a non-essential cookie storing your preferred width of its navigation\u2019s sidebar. This website is hosted by GitHub. They likely record some personally identifiable information such as your IP address. Please refer to GitHub\u2019s privacy statement for details. Furthermore, web fonts are included via Google Fonts API . Google has added a section to their FAQ about privacy implications .","title":"Privacy Statement"},{"location":"recipes/cohda-sdk-build/","text":"Building Vanetza for Cohda MK5 using Cohda SDK This document describes step-by-step how to build Vanetza using the Cohda SDK. At the end, we have Vanetza libraries and its socktap tool cross-compiled for Cohda MK5 devices. Cohda SDK Cohda SDK is provided by Cohda Wireless along with their MK5 units. Since you are reading this build how-to you most likely already possess one of these units. This how-to has been created for the Release 16 of the SDK. The following instructions are expected to be done within the virtual machine (VM) provided by Cohda. Please make sure that a recent GCC version for the arm-linux-gnueabihf target is installed in this VM. I recommend to deinstall g++-4.8-arm-linux-gnueabihf entirely as this version supports C++11 only poorly. g++-5-arm-linux-gnueabihf is known to work well. Vanetza build dependencies Compilation of Vanetza depends on several third-party libraries, e.g. Boost, GeographicLib and Crypto++ as mentioned in Vanetza\u2019s README. Steps to compile those dependencies are described in our cross-compile dependencies document . For the sake of simplicity, we provide the pre-compiled dependencies for Cohda MK5 as compressed archives. Archive Content MD5 checksum vanetza-deps-20171129.tar.bz2 Boost 1.65.1, GeographicLib 1.49, Crypto++ 5.6.5 853a2833fde0266674d4a4dbe22fe7ef vanetza-deps-20191126.tar.bz2 Boost 1.71.0, GeographicLib 1.50, Crypto++ 8.2.0 1d8832949673e3935f72aac6c00a132d At the moment, these archives are hosted on box.com . We recommend to download the most recent archive in general. Before the next step, extract the archive\u2019s content into /home/duser/vanetza-deps . Compile Vanetza We assume you have copy of the Vanetza repository in your home directory at /home/duser/vanetza . Create a build directory and tell CMake to use the cross-compiler installed in the Cohda VM and to look up additional dependencies in vanetza-deps : mkdir vanetza-build cd vanetza-build cmake $HOME /vanetza \\ -DCMAKE_TOOLCHAIN_FILE = $HOME /vanetza/cmake/Toolchain-Cohda-MK5.cmake \\ -DCMAKE_FIND_ROOT_PATH = $HOME /vanetza-deps \\ -DCMAKE_INSTALL_RPATH = \\$ ORIGIN/../lib \\ -DCMAKE_INSTALL_PREFIX = $HOME /vanetza-dist make This builds the Vanetza libraries only. Enable the BUILD_SOCKTAP CMake option if you want to try socktap as well. Additionally, enable the SOCKTAP_WITH_COHDA_LLC CMake option if you want socktap to use 802.11p via Cohda\u2019s LLC network interface on your MK5. Fortunately, socktap \u2018s additional gpsd dependency is already shipped with the Cohda SDK itself. You only need to specify its location by setting GPS_LIBRARY to /home/duser/mk5/stack/v2x-lib/lib/mk5/libgps_static.a and GPS_INCLUDE_DIR to /home/duser/mk5/stack/v2x-lib/include . Please note, that socktap does not make use of Cohda\u2019s socket API currently. We might provide a modified socktap application in the future. Deployment make install Compile and link socktap with correct RPATH, binaries are copied to $HOME/vanetza-dist . copy runtime dependencies Copy the shared object files (*.so) from $HOME/vanetza-deps/libs onto the MK5, e.g. to /home/user/vanetza/lib . copy socktap onto MK5 Copy the files from $HOME/vanetza-dist to /home/user/vanetza on the MK5, i.e. Vanetza libraries and its dependency libraries are located in the same directory. You can execute socktap located at /home/user/vanetza/bin/socktap and it will look up its shared objects in the sibling lib directory. If you have enabled the SOCKTAP_WITH_COHDA_LLC CMake option, make sure to give socktap the name of a Cohda LLC network interface via the command line option --interface / -i (e.g. cw-llc0).","title":"Building for Cohda MK5"},{"location":"recipes/cohda-sdk-build/#building-vanetza-for-cohda-mk5-using-cohda-sdk","text":"This document describes step-by-step how to build Vanetza using the Cohda SDK. At the end, we have Vanetza libraries and its socktap tool cross-compiled for Cohda MK5 devices.","title":"Building Vanetza for Cohda MK5 using Cohda SDK"},{"location":"recipes/cohda-sdk-build/#cohda-sdk","text":"Cohda SDK is provided by Cohda Wireless along with their MK5 units. Since you are reading this build how-to you most likely already possess one of these units. This how-to has been created for the Release 16 of the SDK. The following instructions are expected to be done within the virtual machine (VM) provided by Cohda. Please make sure that a recent GCC version for the arm-linux-gnueabihf target is installed in this VM. I recommend to deinstall g++-4.8-arm-linux-gnueabihf entirely as this version supports C++11 only poorly. g++-5-arm-linux-gnueabihf is known to work well.","title":"Cohda SDK"},{"location":"recipes/cohda-sdk-build/#vanetza-build-dependencies","text":"Compilation of Vanetza depends on several third-party libraries, e.g. Boost, GeographicLib and Crypto++ as mentioned in Vanetza\u2019s README. Steps to compile those dependencies are described in our cross-compile dependencies document . For the sake of simplicity, we provide the pre-compiled dependencies for Cohda MK5 as compressed archives. Archive Content MD5 checksum vanetza-deps-20171129.tar.bz2 Boost 1.65.1, GeographicLib 1.49, Crypto++ 5.6.5 853a2833fde0266674d4a4dbe22fe7ef vanetza-deps-20191126.tar.bz2 Boost 1.71.0, GeographicLib 1.50, Crypto++ 8.2.0 1d8832949673e3935f72aac6c00a132d At the moment, these archives are hosted on box.com . We recommend to download the most recent archive in general. Before the next step, extract the archive\u2019s content into /home/duser/vanetza-deps .","title":"Vanetza build dependencies"},{"location":"recipes/cohda-sdk-build/#compile-vanetza","text":"We assume you have copy of the Vanetza repository in your home directory at /home/duser/vanetza . Create a build directory and tell CMake to use the cross-compiler installed in the Cohda VM and to look up additional dependencies in vanetza-deps : mkdir vanetza-build cd vanetza-build cmake $HOME /vanetza \\ -DCMAKE_TOOLCHAIN_FILE = $HOME /vanetza/cmake/Toolchain-Cohda-MK5.cmake \\ -DCMAKE_FIND_ROOT_PATH = $HOME /vanetza-deps \\ -DCMAKE_INSTALL_RPATH = \\$ ORIGIN/../lib \\ -DCMAKE_INSTALL_PREFIX = $HOME /vanetza-dist make This builds the Vanetza libraries only. Enable the BUILD_SOCKTAP CMake option if you want to try socktap as well. Additionally, enable the SOCKTAP_WITH_COHDA_LLC CMake option if you want socktap to use 802.11p via Cohda\u2019s LLC network interface on your MK5. Fortunately, socktap \u2018s additional gpsd dependency is already shipped with the Cohda SDK itself. You only need to specify its location by setting GPS_LIBRARY to /home/duser/mk5/stack/v2x-lib/lib/mk5/libgps_static.a and GPS_INCLUDE_DIR to /home/duser/mk5/stack/v2x-lib/include . Please note, that socktap does not make use of Cohda\u2019s socket API currently. We might provide a modified socktap application in the future.","title":"Compile Vanetza"},{"location":"recipes/cohda-sdk-build/#deployment","text":"make install Compile and link socktap with correct RPATH, binaries are copied to $HOME/vanetza-dist . copy runtime dependencies Copy the shared object files (*.so) from $HOME/vanetza-deps/libs onto the MK5, e.g. to /home/user/vanetza/lib . copy socktap onto MK5 Copy the files from $HOME/vanetza-dist to /home/user/vanetza on the MK5, i.e. Vanetza libraries and its dependency libraries are located in the same directory. You can execute socktap located at /home/user/vanetza/bin/socktap and it will look up its shared objects in the sibling lib directory. If you have enabled the SOCKTAP_WITH_COHDA_LLC CMake option, make sure to give socktap the name of a Cohda LLC network interface via the command line option --interface / -i (e.g. cw-llc0).","title":"Deployment"},{"location":"recipes/cross-compile-dependencies/","text":"Cross-Compilation of Dependencies This document summarises a few hints for cross-compiling Vanetza\u2019s dependencies. Please note, that cross-compiling is not relevant for you if you plan to use Vanetza on the same system you have built it on. Boost Create a configuration file for Boost.Build in your home directory at $HOME/user-config.jam and add following line to it: using gcc : arm : arm-linux-gnueabihf-g++ ; The install stage does not work in Boost 1.71.0 (and 1.70.0) when cross-compiling. A workaround for this issue is to remove following lines from tools/build/src/tools/common.jam (around line 976): # From GCC 5, versioning changes and minor becomes patch if $(tag) = gcc && [ numbers.less 4 $(version[1]) ] { version = $(version[1]) ; } # Ditto, from Clang 4 if ( $(tag) = clang || $(tag) = clangw ) && [ numbers.less 3 $(version[1]) ] { version = $(version[1]) ; } Then, the required libraries can be built and installed at given prefix path: ./b2 --prefix = $HOME /vanetza-deps --with-date_time --with-program_options --with-system --no-samples --no-tests variant = release link = shared cxxstd = 11 install Crypto++ Version 8.2 can be cross-compiled with the provided GNUmakefile-cross makefile. export CXX = arm-linux-gnueabihf-g++ export PREFIX = $HOME /vanetza-deps export HAS_SOLIB_VERSION = 1 make -f GNUmakefile-cross shared make -f GNUmakefile-cross install GeographicLib Following steps have been tested with version 1.50. $VANETZA refers to the root directory of this repository. mkdir build.arm cd build.arm cmake .. -DCMAKE_TOOLCHAIN_FILE = $VANETZA /cmake/Toolchain-Cohda-MK5.cmake -DCMAKE_BUILD_TYPE = Release -DCMAKE_INSTALL_PREFIX = $HOME /vanetza-deps make install","title":"Cross-Compilation of Dependencies"},{"location":"recipes/cross-compile-dependencies/#cross-compilation-of-dependencies","text":"This document summarises a few hints for cross-compiling Vanetza\u2019s dependencies. Please note, that cross-compiling is not relevant for you if you plan to use Vanetza on the same system you have built it on.","title":"Cross-Compilation of Dependencies"},{"location":"recipes/cross-compile-dependencies/#boost","text":"Create a configuration file for Boost.Build in your home directory at $HOME/user-config.jam and add following line to it: using gcc : arm : arm-linux-gnueabihf-g++ ; The install stage does not work in Boost 1.71.0 (and 1.70.0) when cross-compiling. A workaround for this issue is to remove following lines from tools/build/src/tools/common.jam (around line 976): # From GCC 5, versioning changes and minor becomes patch if $(tag) = gcc && [ numbers.less 4 $(version[1]) ] { version = $(version[1]) ; } # Ditto, from Clang 4 if ( $(tag) = clang || $(tag) = clangw ) && [ numbers.less 3 $(version[1]) ] { version = $(version[1]) ; } Then, the required libraries can be built and installed at given prefix path: ./b2 --prefix = $HOME /vanetza-deps --with-date_time --with-program_options --with-system --no-samples --no-tests variant = release link = shared cxxstd = 11 install","title":"Boost"},{"location":"recipes/cross-compile-dependencies/#crypto","text":"Version 8.2 can be cross-compiled with the provided GNUmakefile-cross makefile. export CXX = arm-linux-gnueabihf-g++ export PREFIX = $HOME /vanetza-deps export HAS_SOLIB_VERSION = 1 make -f GNUmakefile-cross shared make -f GNUmakefile-cross install","title":"Crypto++"},{"location":"recipes/cross-compile-dependencies/#geographiclib","text":"Following steps have been tested with version 1.50. $VANETZA refers to the root directory of this repository. mkdir build.arm cd build.arm cmake .. -DCMAKE_TOOLCHAIN_FILE = $VANETZA /cmake/Toolchain-Cohda-MK5.cmake -DCMAKE_BUILD_TYPE = Release -DCMAKE_INSTALL_PREFIX = $HOME /vanetza-deps make install","title":"GeographicLib"},{"location":"tools/benchmark/","text":"Benchmark Benchmark is a tool to benchmark some components of Vanetza. At the moment, benchmarks for signing and validating packets exist. Installation Benchmarks are not built by default, so you need to enable them explicitly. Run cmake -D BUILD_BENCHMARK=ON .. in your build directory to do so and start the build process again. You should be able to find bin/benchmark in your build directory afterwards. Running You can run bin/benchmark --help to get a list of available benchmarks. You can run these with bin/benchmark <name> then. Acknowledgement This application has been initially developed Niklas Keller .","title":"Benchmark"},{"location":"tools/benchmark/#benchmark","text":"Benchmark is a tool to benchmark some components of Vanetza. At the moment, benchmarks for signing and validating packets exist.","title":"Benchmark"},{"location":"tools/benchmark/#installation","text":"Benchmarks are not built by default, so you need to enable them explicitly. Run cmake -D BUILD_BENCHMARK=ON .. in your build directory to do so and start the build process again. You should be able to find bin/benchmark in your build directory afterwards.","title":"Installation"},{"location":"tools/benchmark/#running","text":"You can run bin/benchmark --help to get a list of available benchmarks. You can run these with bin/benchmark <name> then.","title":"Running"},{"location":"tools/benchmark/#acknowledgement","text":"This application has been initially developed Niklas Keller .","title":"Acknowledgement"},{"location":"tools/certify/","text":"Certify Certify is a tool to create and view certificates and can be used to set up a test PKI for secured V2X communication based on TS 103 097 v1.2.1. Installation You need to enable building this tool explicitly. Run cmake -D BUILD_CERTIFY=ON .. in your build directory and rebuild Vanetza. You should be able to find bin/certify in your build directory afterwards. PKI Setup The following section describe how to setup a test PKI. We will generate a root certificate, an authorization authority certificate and an authorization ticket. Generating Keys New private keys can be generated using bin/certify generate-key root.key . The corresponding public key can be extracted using bin/certify extract-public-key --private-key root.key root.pub , but this step usually isn\u2019t required. Please generate a root.key for the root certificate, a aa.key for the authorization authority and a ticket.key for the authorization ticket. Generating Root Certificates A root certificate can be generated using bin/certify generate-root --subject-key root.key root.cert . Generating Authorization Authorities An authorization authority certificate can be generated using bin/certify generate-aa --sign-key root.key --sign-cert root.cert --subject-key aa.key aa.cert . Generating Authorization Tickets An authorization ticket can be generated using bin/certify generate-ticket --sign-key aa.key --sign-cert aa.cert --subject-key ticket.key ticket.cert . If you\u2019re generating a certificate for real V2X hardware, it will likely use a hardware security module (HSM), which will only expose the public key. You can export the given public key to a file and use --subject-key also with public keys. The public key needs to be encoded according to the rules specified by ETSI in TS 103 097 v1.2.1. Other Options This guide only uses the required options. Further options may be available for certain commands. Use bin/certify <command> --help for further information. Acknowledgement This application has been initially developed Niklas Keller .","title":"Certify"},{"location":"tools/certify/#certify","text":"Certify is a tool to create and view certificates and can be used to set up a test PKI for secured V2X communication based on TS 103 097 v1.2.1.","title":"Certify"},{"location":"tools/certify/#installation","text":"You need to enable building this tool explicitly. Run cmake -D BUILD_CERTIFY=ON .. in your build directory and rebuild Vanetza. You should be able to find bin/certify in your build directory afterwards.","title":"Installation"},{"location":"tools/certify/#pki-setup","text":"The following section describe how to setup a test PKI. We will generate a root certificate, an authorization authority certificate and an authorization ticket.","title":"PKI Setup"},{"location":"tools/certify/#generating-keys","text":"New private keys can be generated using bin/certify generate-key root.key . The corresponding public key can be extracted using bin/certify extract-public-key --private-key root.key root.pub , but this step usually isn\u2019t required. Please generate a root.key for the root certificate, a aa.key for the authorization authority and a ticket.key for the authorization ticket.","title":"Generating Keys"},{"location":"tools/certify/#generating-root-certificates","text":"A root certificate can be generated using bin/certify generate-root --subject-key root.key root.cert .","title":"Generating Root Certificates"},{"location":"tools/certify/#generating-authorization-authorities","text":"An authorization authority certificate can be generated using bin/certify generate-aa --sign-key root.key --sign-cert root.cert --subject-key aa.key aa.cert .","title":"Generating Authorization Authorities"},{"location":"tools/certify/#generating-authorization-tickets","text":"An authorization ticket can be generated using bin/certify generate-ticket --sign-key aa.key --sign-cert aa.cert --subject-key ticket.key ticket.cert . If you\u2019re generating a certificate for real V2X hardware, it will likely use a hardware security module (HSM), which will only expose the public key. You can export the given public key to a file and use --subject-key also with public keys. The public key needs to be encoded according to the rules specified by ETSI in TS 103 097 v1.2.1.","title":"Generating Authorization Tickets"},{"location":"tools/certify/#other-options","text":"This guide only uses the required options. Further options may be available for certain commands. Use bin/certify <command> --help for further information.","title":"Other Options"},{"location":"tools/certify/#acknowledgement","text":"This application has been initially developed Niklas Keller .","title":"Acknowledgement"},{"location":"tools/socktap/","text":"Socktap socktap runs Vanetza on top of Linux raw packet sockets and demonstrates the basic API usage. This enables tests on commodity hardware, i.e. no special V2X or Car2X hardware is required. However, raw packet sockets cannot replace such dedicated hardware entirely. Consider socktap as an experimental application showcasing some of Vanetza\u2019s features. You can enable the build process for this application by the BUILD_SOCKTAP CMake option. When socktap is going to be built, gpsd is required as an additional dependency. Warning A bug in gpsd<=3.15 causes a segmentation fault when socktap tries to fetch GPS data. More recent versions include a bugfix, e.g. gpsd>=3.17 is known to work. See also the corresponding issue ticket #69 . If you have access to V2X hardware from Cohda Wireless, you can also run socktap on their units. A special CMake option SOCKTAP_WITH_COHDA_LLC exists to build socktap for operation on Cohda\u2019s LLC API. Please refer to our Cohda SDK building recipe for details. Variants There are multiple variants of socktap . socktap-hello sends simple BTP-B messages with the binary payload 0xc0ffee . socktap-cam sends vehicle CAM messages and optionally supports some security options. Permissions Since socktap builds upon raw packet sockets you need to run it with special privileges. Either run socktap as root user or set the CAP_NET_RAW capabilities on the executables. You can do this via sudo setcap cap_net_raw+ep bin/socktap-<variant> . When CAP_NET_RAW is attached to the socktap binary you can run it as ordinary user. Running You can locate socktap in your build directory at bin/socktap- . It requires the network device name as startup argument on which socktap should send and receive packets. Usually, such devices are named eth0 or wlan0 . You can look up the available devices on your machine with the ip link command. If you want to use the local loopback device (usually lo ) you need to override the used MAC address using --mac-address to receive packets. This is due to the MAC address being 00:00:00:00:00:00 for both sides and the router dropping incoming packets with its own address. Acknowledgement This demo application has been initially developed as part of a student\u2019s project at Hochschule Darmstadt in summer term 2016. Participating students were in alphabetical order: Sachin Kashyap Bukkambudhi Satyanarayana, Alvita Marina Menezes, Mrunmayi Parchure, Subashini Rajan and Deeksha Venkadari Yogendra. Since then, @kelunik and @glmax have contributed a lot to socktap .","title":"Socktap"},{"location":"tools/socktap/#socktap","text":"socktap runs Vanetza on top of Linux raw packet sockets and demonstrates the basic API usage. This enables tests on commodity hardware, i.e. no special V2X or Car2X hardware is required. However, raw packet sockets cannot replace such dedicated hardware entirely. Consider socktap as an experimental application showcasing some of Vanetza\u2019s features. You can enable the build process for this application by the BUILD_SOCKTAP CMake option. When socktap is going to be built, gpsd is required as an additional dependency. Warning A bug in gpsd<=3.15 causes a segmentation fault when socktap tries to fetch GPS data. More recent versions include a bugfix, e.g. gpsd>=3.17 is known to work. See also the corresponding issue ticket #69 . If you have access to V2X hardware from Cohda Wireless, you can also run socktap on their units. A special CMake option SOCKTAP_WITH_COHDA_LLC exists to build socktap for operation on Cohda\u2019s LLC API. Please refer to our Cohda SDK building recipe for details.","title":"Socktap"},{"location":"tools/socktap/#variants","text":"There are multiple variants of socktap . socktap-hello sends simple BTP-B messages with the binary payload 0xc0ffee . socktap-cam sends vehicle CAM messages and optionally supports some security options.","title":"Variants"},{"location":"tools/socktap/#permissions","text":"Since socktap builds upon raw packet sockets you need to run it with special privileges. Either run socktap as root user or set the CAP_NET_RAW capabilities on the executables. You can do this via sudo setcap cap_net_raw+ep bin/socktap-<variant> . When CAP_NET_RAW is attached to the socktap binary you can run it as ordinary user.","title":"Permissions"},{"location":"tools/socktap/#running","text":"You can locate socktap in your build directory at bin/socktap- . It requires the network device name as startup argument on which socktap should send and receive packets. Usually, such devices are named eth0 or wlan0 . You can look up the available devices on your machine with the ip link command. If you want to use the local loopback device (usually lo ) you need to override the used MAC address using --mac-address to receive packets. This is due to the MAC address being 00:00:00:00:00:00 for both sides and the router dropping incoming packets with its own address.","title":"Running"},{"location":"tools/socktap/#acknowledgement","text":"This demo application has been initially developed as part of a student\u2019s project at Hochschule Darmstadt in summer term 2016. Participating students were in alphabetical order: Sachin Kashyap Bukkambudhi Satyanarayana, Alvita Marina Menezes, Mrunmayi Parchure, Subashini Rajan and Deeksha Venkadari Yogendra. Since then, @kelunik and @glmax have contributed a lot to socktap .","title":"Acknowledgement"}]}